---
weight: 1135
title: "6.01 Carrier Frequency Synchronization"
icon: keyboard_double_arrow_right
description: "How to configure Breadcrumb navigation for your Lotus Docs site."
date: 2022-11-27T07:08:15+00:00
lastmod: 2023-08-16T02:49:15+00:00
aliases:
    - ../guides/theme-options/breadcrumbs
draft: false
images: []
toc: true
katex: true
---


## 6.4 Non-Timing-Aided Techniques

수신 신호에 Carrier Frequency Offset이 매우 크게 발생한다면 Frame Synchronization이 불가능하기 때문에 수신 신호의 시작점이 어딘지 알 수 없다.

또한 Frame Synchronization이 되더라도 정확한 심볼 타이밍을 알 수 없기 때문에 데이터를 복조 할 수 없게 된다.

따라서 타이밍을 알 수 없는 상태에서 CFO를 심볼 타이밍 추정이 가능한 정도로 낮추는 보정이 필요하다.

이 단계를 Coarse Frquency Offset Synchronization이라고 한다.

### 6.4.1 Feedforward(Non-Timing) - Delay & Multiply Technique (Coarse CFO Recovery)
송신 신호가 버스트 모드 신호일 경우, 신호의 길이가 짧다. 따라서 CFO를 추정하기 위해서 빠른 보정 알고리즘이 필요하다.

이러한 경우 짧은 주파수 오프셋 추정 시간과 넓은 주파수 오프셋 범위를 보정할 수 있는 Feedforward 방식이 필요하다. 

이 중 대표적인 방식이 Delay & Multiply 기법이다.

이 기법의 본질적인 아이디어는 수신 신호를 구성하는 두 샘플간의 위상 차이를 바탕으로 주파수 오프셋을 추정하는 기법이다.

일반적으로 두 샘플간 위상 차이 $\triangle\phi$는 아래와 같이 정의된다.

$$ \triangle\phi = 2 \pi F(T_2-T_1) $$

이 때 $F$는 신호가 갖는 연속 시간 주파수이고 $T_S = T_2-T_1$가 성립한다.

이제 우리가 할 과제는 수신 신호를 복소수 사인파에 잡음이 섞인 형태로 바꾸어서 위상 차 $\triangle\phi$를 추정하는 것이다.

아래 그림은 모뎀의 송/수신부 부분을 다시 나타낸다.

![Internal link preview tooltip](/images/content/cfo/pic2.png)

Carrier Frequency $F_C$로 Down-Conversion된 신호를 $x(nT_S)$라고 표현하자. 이 신호는 CFO를 포함하고 있다고 가정해보자.

$x(nT_S)$신호는 CFO를 포함하고 있기 때문에 결국 송신부에서 Pulse Shaping이 이루어진 이후의 신호 $v(nT_S)$에 주파수 오프셋이 곱해진 형태로 나타난다.

$$x_I(nT_S) = v_I(nT_S)cos2 \pi F_\triangle nT_S - v_Q(nT_S)sin 2 \pi F_\triangle nT_S$$

$$x_Q(nT_S) = v_Q(nT_S)cos2 \pi F_\triangle nT_S + v_I(nT_S)sin 2 \pi F_\triangle nT_S$$

먼저 할 일은 이 신호를 최악의 CFO인 $F_\triangle,max$의 Passband로 갖는 LPF로 통과시킨다. 이 과정을 통해 포함되어 있는 잡음 성분을 억제시킨다.

그 다음은 Down-Conversion된 신호 $x(nT_S)$를 i개의 샘플만큼 Delay시켜 만든 $x(nT_S-iT_S)$를 만든다.

그런 다음 딜레이 시킨 신호를 Conjugate 곱을 하여 만든 신호 $y(nT_S)$를 만든다.

$$ y(nT_S) = x(nT_S)x^*(nT_S-iT_S)$$

$y(nT_S)$가 어떻게 만들어졌는지 더 잘 이해하기 위해 아래 그림을 참고해보자.

![Internal link preview tooltip](/images/content/cfo/pic3.png)

이제 복소수 형태의 신호 $y(nT_S)$를 실수부와 허수부로 각각 표현해보자.

$$ y_I(nT_S) = x_I(nT_S)x_I(nT_S-iT_S) + x_Q(nT_S)x_Q(nT_S-iT_S)$$
$$ y_Q(nT_S) = x_Q(nT_S)x_I(nT_S-iT_S) - x_I(nT_S)x_Q(nT_S-iT_S)$$

위 식에 조금 더 위에서 유도했던 식$x_I(nT_S)$와 $x_Q(nT_S)$값을 대입해보자. 식을 잘 정리해보면 아래와 같이 유도된다.

$$y_I(nT_s) = W_I(nT_s) \cos(2\pi F_\Delta iT_s) - W_Q(nT_s) \sin(2\pi F_\Delta iT_s)$$
$$y_Q(nT_s) = W_Q(nT_s) \cos(2\pi F_\Delta iT_s) + W_I(nT_s) \sin(2\pi F_\Delta iT_s)$$

$$ W_I(T_s) = v_I(nT_s) v_I(nT_s - iT_s) + v_Q(nT_s) v_Q(nT_s - iT_s) $$
$$ W_Q(T_s) = v_Q(nT_s) v_I(nT_s - iT_s) - v_I(nT_s) v_Q(nT_s - iT_s) $$

이 때 $y_I$와 $y_Q$를 구할 때 수신 신호 $x(nT_S)$를 지연을 준 후, conjugate를 수행했다. 이 때 conjugate를 수행함으로써 수신 신호에 걸린 변조 성분이 제거 되고 순수 주파수 성분만 남게 된다. 따라서 $W(nT_S)$를 다시 쓸 수 있다.

$$W_I(nT_s) = v_I^2(nT_s) + v_Q^2(nT_s) = 1 $$
$$W_Q(nT_s) = v_Q(nT_s) v_I(nT_s - iT_s) - v_I(nT_s) v_Q(nT_s - iT_s) = 0 $$

따라서 

$$y_I(nT_S) = cos(2\pi F_\Delta iT_s)$$
$$y_Q(nT_S) = sin(2\pi F_\Delta iT_s)$$

으로 식이 정리된다. 위 식은 주파수가 $F_\Delta$인 정현파 신호다.

따라서 우리는 수신 신호를 CFO가 포함된 복소수 정현파 신호 형태로 나타낼 수 있게 되었다.

그리고 $y(nT_S)$의 위상을 통해 $F_\Delta$를 추출할 수 있게 되었다. 방법은 간단하다.

$$
\begin{aligned}
\tan^{-1}\left(\frac{y_Q(nT_s)}{y_I(nT_s)}\right) = 2 \pi F_\Delta i T_s \\
\therefore \quad F_\Delta = \frac{1}{2 \pi i T_s} \sum_{n=0}^{N_d-1} \tan^{-1}\left(\frac{y_Q(nT_s)}{y_I(nT_s)}\right)
\end{aligned}
$$

여기서 $N_d$는 $y(nT_S)$의 길이다. 즉 $y(nT_S)$의 샘플의 I/Q 위상차이를 모두 더해서 최종 결과를 도출하는 것이다.

그리고 일반적으로 Delay 샘플은 1개 샘플로 정의한다. 즉 $i=1$이다.

피드포워드 기반 Delay and Multiply CFO 추정기 방식은 예상되는 최대 CFO만큼을 추정하기 위해서 수신 대역폭을 최대 CFO만큼 Passband로 가져가야 한다.

이럴 경우 수신 신호는 많은 잡음을 포함할 뿐 아니라, 인접 채널의 간섭도 영향을 받게 된다.

또한 CFO가 시간에 따라 서서히 변할 경우 추정 값이 부정확할 수 있다.

### 6.4.2 Feedback(Non-Timing) - Derivative Frequency Error Detector (Coarse CFO Recovery)

또 다른 기법으로 미분을 활용한 Feedback 방식의 CFO 추정기가 존재한다.

우리는 Feedback 방식을 활용해 CFO를 추정하는 FLL 형태의 CFO 추정기를 유도하기 위해 기본이 되는 Derivative CFO 추정기에 대해 소개한다.

이해를 위해 먼저 CFO가 수신 신호의 에너지에 어떤 영향을 끼치는지 살펴보자.

먼저 프리앰블을 사용할 수 있는 경우 Matched Filtering 출력 신호와 프리앰블간의 Correlation식은 아래와 같다.

![Internal link preview tooltip](/images/content/cfo/pic4.png)

그러나 우리는 Coarse CFO를 추정하는 단계에서 Frame Synchronization을 할 수 없기 때문에 타이밍 정보가 없고, 결국 프리앰플의 정보도 알지 못한다.

따라서 우리는 $a[m]$ 대신 Matched Filtering의 출력을 대신 사용한다. 따라서 상관관계 식은 $\sum_{n}|z(nT_S)|^2$ 이 된다.

시간축 샘플의 제곱의 합이 시간 축 신호의 에너지를 의미하므로 수신 신호의 에너지는 아래와 같이 다시 쓸 수 있다.

![Internal link preview tooltip](/images/content/cfo/pic5.png)

이제 Matched Filtering을 수행할 때 CFO의 추정값에 따라 신호의 에너지가 어떻게 바뀌는 지 살펴보자.

![Internal link preview tooltip](/images/content/cfo/pic6.png)

SRRC Matched Filter는 빨간색 점선으로 나타나 있고 파란색 신호는 CFO를 수신 신호에 보상한 스펙트럼이다.

그림을 보면 알 수 있듯이, CFO의 추정 값 $\hat{F}_\triangle $ 실제 CFO 값에 가까워 질수록 Matched Filter의 출력 신호의 에너지가 커짐을 알 수 있다.

즉 CFO가 보정되고 난 후 신호의 Matched Filtering 출력 신호의 에너지는 CFO 추정값과 실제 CFO값의 차이가 매우 클 때는 0에서 시작하여 차이가 0일 때는 에너지가 최대가 되는 형태를 띄게 된다.

즉 비타이밍 Coarse CFO는 이 에너지를 최대화 하는 방식으로 추정이 이루어진다.

여기서 우리는 FLL(Frequency-Locked-Loop)를 활용한다. 신호의 에너지를 최대로 만드는 CFO 추정값을 FLL의 입력으로 넣고 루프 필터를 돌리며 최종 CFO 값을 찾는 것이다.

이제 Matched Filtering의 출력 신호 $z(nT_S)$ 에너지를 최대로 만드는 방법을 찾아보자.

시간 축에서 에너지를 계산하기 위해 시간 축 샘플을 각각 제곱하면 된다. 복소수의 제곱은 복소수와 복소수의 켤레복소수의 곱으로 구할 수 있다.

$$ |z(nT_S)|^2 = {z(nT_S)z^{*}(nT_S)}$$

이제 $|z(nT_S)|^2$를 최대로 만드는 $\hat{F}_\triangle$을 찾아보자. 이를 위해 미분을 활용한다.

미분 값이 0일 때 원함수는 최대 또는 최소의 크기를 갖는다. 신호의 에너지는 음수가 없으므로 최댓값만 존재한다. 따라서 미분 값이 0일 때 원함수(신호 에너지)는 최대가 된다. 아래 식을 통해 유도해보자.

![Internal link preview tooltip](/images/content/cfo/pic7.png)

한편 FLL의 목적은 오류 신호를 0으로 만드는 것이기 때문에 결국 이 도함수를 오류 신호로 활용할 수 있게 된다. 왜냐면 목적이 모두 0이 되는 것이기 때문이다.


![Internal link preview tooltip](/images/content/cfo/pic8.png)

이러한 방식을 최대 우도 기반 FED (Maximum Likelihood FED)라고도 표현한다.

그러나 이 도함수를 FED의 출력으로 활용하는 것은 문제가 있다. 왜냐면 미분 연산은 신호 내 고주파 성분을 강조해 잡음이 많은 환경에서 오류가 발생할 수 있기 때문이다.

그래서 우리는 더 효율적인 방식으로 FED를 수정해야한다. 아래 그림을 참고해보자.